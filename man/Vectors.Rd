% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/homomorphicOps.R
\name{Vectors}
\alias{Vectors}
\alias{c}
\alias{prod}
\alias{sum}
\title{Vectors of cipher texts}
\usage{
enc(keys$pk1, c(m1, m2, ...))
c(ct1, ct2)

ct1 + ct2
ct1 - ct2
ct1 * ct2
ct1 \%*\% ct2
sum(ct1)
prod(ct1)
}
\description{
Vectors of cipher texts can be seemlessly created and manipulated in the same
way one normally works with vectors in R.
}
\details{
Vectors of cipher texts can be seemlessly created either at encryption time
by passing a vector message argument to \code{\link{enc}}, or after encryption
using the standard concatenation operator \code{\link[base]{c}}.

Standard operations which can be used on regular vectors can also be used
on vectors of cipher texts, where the scheme supports it.

As with regular scalar operations, note that not all homomorphic encryption
schemes will support all vector operations.
Also, it is important to note that typically homomorphic operations cause
an increase in the noise within a ciphertext.  Once a certain number of
operations have taken place the cipertext may no longer correctly decrypt.
If a scheme is *fully* homomorphic, then it may be possible to apply a
bootstrapping procedure which reduces the noise.
}
\examples{
p <- pars("FandV")
keys <- keygen(p)
ct1 <- enc(keys$pk, c(2,3))
ct2 <- enc(keys$pk, c(4,5))
ctConcat <- c(ct1, ct2)
ctAdd <- ct1 + ct2
ctSub <- ct1 - ct2
ctMul <- ct1 * ct2
ctIP <- ct1 \%*\% ct2

# Decrypt to the equivalent of the above operations applied to the vectors
# c(2,3) and c(4,5)
dec(keys$sk, ctConcat)
dec(keys$sk, ctAdd)
dec(keys$sk, ctSub)
dec(keys$sk, ctMul)
dec(keys$sk, ctIP)
}

