#' Generate cryptographic keys
#' 
#' This function will generate cryptographic keys to enable encryption, decryption
#' and possibly other operations (such as relinearisation or bootstrapping) for
#' the homomorphic encryption schemes supported in this package.
#' 
#' The scheme to be used is determined by the type of the parameters object,
#' \code{p}.
#' 
#' @param p a parameters object as produced by the \code{\link{pars}} function.
#' 
#' @return
#' A list object containing the keys will be returned
#' 
#' Depending on the scheme specified by the parameters object the exact structure
#' will vary.  For example, a symmetric key scheme will only return a private key,
#' whereas a public key scheme will return a public and private keypair.
#' Certain schemes may include additional keys for operations such as
#' relinearisation or bootstrapping.  The keys will be named \code{pk} (public),
#' \code{sk} (private), \code{rlk} (relinearisation), \code{bk} (bootstrapping)
#' in the list object if they are part of the scheme.
#' 
#' @seealso
#' \code{\link{pars}} for generating the parameters for a scheme; \code{\link{enc}}
#' for encrypting messages using the keys generated by this function.
#' 
#' @examples
#' p <- pars("FandV")
#' keys <- keygen(p)
#' 
#' # Look at public key and encrypt
#' keys$pk
#' ct <- enc(keys$pk, 1)
#' 
#' # Look at private key and decrypt
#' keys$sk
#' dec(keys$sk, ct)
#' 
#' # Obviously a different private key won't be able to decrypt
#' keys2 <- keygen(p)
#' keys2$sk
#' dec(keys2$sk, ct)
#' 
#' @author Louis Aslett
keygen <- function(p) {
  if(is.null(attr(p, "FHEt")) || attr(p, "FHEt")!="pars") stop("p argument does not contain cryptography parameters.")
  UseMethod("keygen", p);
}

keygen.Rcpp_FandV_par <- function(p) {
  pk <- new(FandV_pk, rlkLocker, 0)
  sk <- new(FandV_sk)
  rlk <- new(FandV_rlk)
  p$keygen(pk, sk, rlk)
  attr(pk, "FHEt") <- "pk"
  attr(pk, "FHEs") <- "FandV"
  attr(sk, "FHEt") <- "sk"
  attr(sk, "FHEs") <- "FandV"
  attr(rlk, "FHEt") <- "rlk"
  attr(rlk, "FHEs") <- "FandV"
  res <- list(sk=sk, pk=pk, rlk=rlk)
  class(res) <- "FandV_keys"
  attr(res, "FHEt") <- "keys"
  attr(res, "FHEs") <- "FandV"
  res
}

# keygen.FandV_CRT <- function(p) {
#   res <- list(pk=list(), sk=list(), rlk=list())
#   for(i in 1:length(p)) {
#     pk <- new(FandV_pk)
#     sk <- new(FandV_sk)
#     rlk <- new(FandV_rlk)
#     p[[i]]$keygen(pk, sk, rlk)
#     attr(pk, "FHEt") <- "pk"
#     attr(pk, "FHEs") <- "FandV"
#     attr(sk, "FHEt") <- "sk"
#     attr(sk, "FHEs") <- "FandV"
#     attr(rlk, "FHEt") <- "rlk"
#     attr(rlk, "FHEs") <- "FandV"
#     res$pk[[i]] <- pk
#     res$sk[[i]] <- sk
#     res$rlk[[i]] <- rlk
#     list(sk=sk, pk=pk, rlk=rlk)
#   }
#   class(res$pk) <- "FandV_CRT_pk"
#   attr(res$pk, "FHEt") <- "pk"
#   attr(res$pk, "FHEs") <- "FandV_CRT"
#   class(res$sk) <- "FandV_CRT_sk"
#   attr(res$sk, "FHEt") <- "sk"
#   attr(res$sk, "FHEs") <- "FandV_CRT"
#   class(res$rlk) <- "FandV_CRT_rlk"
#   attr(res$rlk, "FHEt") <- "rlk"
#   attr(res$rlk, "FHEs") <- "FandV_CRT"
#   class(res) <- "FandV_CRT_keys"
#   attr(res, "FHEt") <- "keys"
#   attr(res, "FHEs") <- "FandV_CRT"
#   res
# }
